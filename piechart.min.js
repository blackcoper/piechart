(function() {
  $(function() {
    $.piechart = function(element, options) {
      var DEFAULTS, Polygon, TextArc, _, cos, cosBAR, deg2rad, limit, rad2deg, sin, sinBAR;
      DEFAULTS = {
        DATA: [0, 0, 0],
        X: 0,
        Y: 0,
        RADIUS: 200,
        ANGLE: -90,
        BGCOLOR: null,
        COLOR: [['#94c79a', '#7AB355'], ['#20bfe2', '#00ABE8'], ['#f7af76', '#F19446']],
        COLOR_LABEL: ['#F15C53', '#47C2E8', '#A5C93A'],
        TEXT_LABEL: ['FISIK', 'SOCIAL', 'AKAL'],
        FONTFAMILY_LABEL: "bold 24px Arial",
        FONTCOLOR_LABEL: "#000",
        BGCOLOR_LABEL: "#e7bb63",
        useGradient: true,
        download: function() {
          return {};
        }
      };
      _ = this;
      deg2rad = function(a) {
        return a / 180 * Math.PI;
      };
      rad2deg = function(a) {
        return a * 180 / Math.PI;
      };
      cos = function(a) {
        return Math.cos(a);
      };
      sin = function(a) {
        return Math.sin(a);
      };
      cosBAR = function(a, r, x) {
        var _a;
        _a = deg2rad(a);
        return x + cos(_a) * r;
      };
      sinBAR = function(a, r, y) {
        var _a;
        _a = deg2rad(a);
        return y + sin(_a) * r;
      };
      limit = function(value, inMin, inMax, outMin, outMax) {
        return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
      };
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(f) {
        return setTimeout(f, 1000 / 60);
      };
      window.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || function(i) {
        return clearTimeout(i);
      };
      Polygon = function(x, y, radius, sides, pointSize, angle) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.sides = sides;
        this.pointSize = pointSize;
        this.angle = angle;
      };
      Polygon.prototype.exec = function(ctx) {
        var a, angle, i, ps, radius, sides, x, y;
        x = this.x;
        y = this.y;
        radius = this.radius;
        angle = this.angle;
        sides = this.sides;
        ps = 1 - (this.pointSize || 0);
        a = 360 / sides;
        ctx.moveTo(cosBAR(angle, radius, x), sinBAR(angle, radius, y));
        i = 0;
        while (i < sides) {
          angle += a;
          ctx.lineTo(cosBAR(angle, radius, x), sinBAR(angle, radius, y));
          i++;
        }
        return ctx.closePath();
      };
      TextArc = function(text, font, color, x, y, radius, angle, space) {
        this.text = text != null ? text : {
          text: ''
        };
        this.font = font;
        this.color = color;
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.angle = angle;
        this.space = space;
      };
      TextArc.prototype.exec = function(container) {
        var _angle, _t, _wt, charWid, len, n, results, t, textHeight, widthTextAngle;
        len = this.text.length;
        this.space = this.space || 3;
        n = 0;
        _t = [];
        widthTextAngle = 0;
        while (n < len) {
          t = new createjs.Text();
          t.text = this.text[n];
          t.font = this.font;
          t.color = this.color;
          t.textAlign = "center";
          t.textBaseline = "middle";
          charWid = t.getMeasuredWidth();
          textHeight = t.getMeasuredHeight();
          widthTextAngle += rad2deg((charWid + this.space) / this.radius);
          container.addChild(t);
          _t.push(t);
          n++;
        }
        n = 0;
        _angle = this.angle - widthTextAngle / 2;
        results = [];
        while (n < len) {
          charWid = _t[n].getMeasuredWidth();
          textHeight = _t[n].getMeasuredHeight();
          _wt = rad2deg(((charWid + this.space) / 2) / this.radius);
          _t[n].x = cosBAR(_angle + _wt, this.radius, this.x);
          _t[n].y = sinBAR(_angle + _wt, this.radius, this.y);
          _t[n].rotation = 90 + _angle + _wt;
          _angle += _wt + rad2deg(((charWid + this.space) / 2) / this.radius);
          results.push(n++);
        }
        return results;
      };
      _.init = function() {
        var HEIGHT, WIDTH, background, canvas, container, shape, shapeData, stage;
        _.data = DEFAULTS.DATA;
        _.OPTIONS = $.extend({}, DEFAULTS, options);
        WIDTH = 500;
        HEIGHT = 500;
        canvas = $('<canvas>');
        $(element).append(canvas);
        canvas.attr({
          width: WIDTH,
          height: HEIGHT
        });
        stage = new createjs.Stage(canvas.get(0));
        background = new createjs.Shape();
        background.regX = stage.canvas.width / 2;
        background.regY = stage.canvas.height / 2;
        container = new createjs.Container();
        container.x = stage.canvas.width / 2;
        container.y = stage.canvas.height / 2;
        stage.addChild(container);
        background.graphics.f(_.OPTIONS.BGCOLOR).drawRect(0, 0, WIDTH, HEIGHT);
        container.addChild(background);
        shape = new createjs.Shape();
        shapeData = new createjs.Shape();
        _._draw = function(id, v, _angle, _mid) {
          var _gap1, _gap2, _hg, end, start;
          _gap1 = 1;
          _gap2 = 0.3;
          if (!_.OPTIONS.useGradient) {
            start = {
              x: cosBAR(_.OPTIONS.ANGLE + _angle / 4, _.OPTIONS.RADIUS, _.OPTIONS.X),
              y: sinBAR(_.OPTIONS.ANGLE + _angle / 4, _.OPTIONS.RADIUS, _.OPTIONS.Y)
            };
            end = {
              x: cosBAR(_.OPTIONS.ANGLE + _angle - _gap2, _.OPTIONS.RADIUS / 2, _.OPTIONS.X),
              y: sinBAR(_.OPTIONS.ANGLE + _angle - _gap2, _.OPTIONS.RADIUS / 2, _.OPTIONS.Y)
            };
            shapeData.graphics.beginLinearGradientFill(_.OPTIONS.COLOR[id], [0, 1], start.x, start.y, end.x, end.y).mt(cosBAR(_mid, _gap1, _.OPTIONS.X), sinBAR(_mid, _gap1, _.OPTIONS.Y)).arc(0, 0, _.OPTIONS.RADIUS * v, deg2rad(_.OPTIONS.ANGLE + _gap2), deg2rad(_.OPTIONS.ANGLE + _angle - _gap2), false).cp();
          } else {
            if (_.OPTIONS.COLOR[id]) {
              shapeData.graphics.f(_.OPTIONS.COLOR[id][0]).mt(cosBAR(_mid, _gap1, _.OPTIONS.X), sinBAR(_mid, _gap1, _.OPTIONS.Y)).arc(0, 0, _.OPTIONS.RADIUS * v, deg2rad(_.OPTIONS.ANGLE + _gap2), deg2rad(_.OPTIONS.ANGLE + _angle - _gap2), false).cp();
              shapeData.graphics.f(_.OPTIONS.COLOR[id][1]).mt(cosBAR(_.OPTIONS.ANGLE + _angle / 2, _gap1, _.OPTIONS.X), sinBAR(_.OPTIONS.ANGLE + _angle / 2, _gap1, _.OPTIONS.Y)).lt(cosBAR(_.OPTIONS.ANGLE + _angle / 2, _gap1 + 2, _.OPTIONS.X), sinBAR(_.OPTIONS.ANGLE + _angle / 2, _gap1 + 2, _.OPTIONS.Y)).lt(cosBAR(_.OPTIONS.ANGLE + _angle - _gap2 - 1, _.OPTIONS.RADIUS * v, _.OPTIONS.X), sinBAR(_.OPTIONS.ANGLE + _angle - _gap2 - 1, _.OPTIONS.RADIUS * v, _.OPTIONS.Y)).lt(cosBAR(_.OPTIONS.ANGLE + _angle - _gap2, _.OPTIONS.RADIUS * v, _.OPTIONS.X), sinBAR(_.OPTIONS.ANGLE + _angle - _gap2, _.OPTIONS.RADIUS * v, _.OPTIONS.Y)).cp();
            }
          }
          _hg = 35;
          return shape.graphics.f(_.OPTIONS.BGCOLOR_LABEL).mt(cosBAR(_.OPTIONS.ANGLE + _gap2, _.OPTIONS.RADIUS + _gap1, _.OPTIONS.X), sinBAR(_.OPTIONS.ANGLE + _gap2, _.OPTIONS.RADIUS + _gap1, _.OPTIONS.Y)).lt(cosBAR(_.OPTIONS.ANGLE + _gap2, _.OPTIONS.RADIUS + _hg, _.OPTIONS.X), sinBAR(_.OPTIONS.ANGLE + _gap2, _.OPTIONS.RADIUS + _hg, _.OPTIONS.Y)).arc(0, 0, _.OPTIONS.RADIUS + _hg, deg2rad(_.OPTIONS.ANGLE + _gap2), deg2rad(_.OPTIONS.ANGLE + _angle - _gap2), false).lt(cosBAR(_.OPTIONS.ANGLE + _angle - _gap2, _.OPTIONS.RADIUS + _gap1, _.OPTIONS.X), sinBAR(_.OPTIONS.ANGLE + _angle - _gap2, _.OPTIONS.RADIUS + _gap1, _.OPTIONS.Y)).arc(0, 0, _.OPTIONS.RADIUS + _gap1, deg2rad(_.OPTIONS.ANGLE + _angle - _gap2), deg2rad(_.OPTIONS.ANGLE + _gap2), true).cp();
        };
        _.setData = function(ss) {
          var _angle, _mid, a, data, i, id, j, len1, n, ref, v;
          _angle = _.OPTIONS.ANGLE;
          data = ss ? ss : _.OPTIONS.DATA;
          shapeData.graphics.c();
          for (id in data) {
            _angle = 360 / data.length;
            _mid = _.OPTIONS.ANGLE + _angle / 2;
            v = 0;
            if (typeof data[id] === 'number') {
              v = Math.max(Math.min(data[id], 1), 0);
            } else {
              n = 0;
              ref = data[id];
              for (j = 0, len1 = ref.length; j < len1; j++) {
                i = ref[j];
                if (i) {
                  n++;
                }
              }
              v = n / data[id].length;
            }
            this._draw(id, v, _angle, _mid);
            a = new TextArc(_.OPTIONS.TEXT_LABEL[id], _.OPTIONS.FONTFAMILY_LABEL, _.OPTIONS.FONTCOLOR_LABEL, _.OPTIONS.X, _.OPTIONS.Y, _.OPTIONS.RADIUS + 17, _.OPTIONS.ANGLE + _angle / 2);
            a.exec(container);
            _.OPTIONS.ANGLE += _angle;
          }
          return stage.update();
        };
        _.download = function(link, filename, format, encoder) {
          link.href = canvas.get(0).toDataURL(format, encoder);
          return link.download = filename;
        };
        _.get64 = function() {
          return canvas.get(0).toDataURL();
        };
        container.addChild(shape);
        container.addChild(shapeData);
        return _.setData();
      };
      _.init();
      return _;
    };
    return $.fn.piechart = function(options) {
      return this.each(function() {
        var _;
        if (!$(this).data('piechart')) {
          _ = new $.piechart(this, options);
          return $(this).data('piechart', _);
        }
      });
    };
  });

}).call(this);

//# sourceMappingURL=piechart.min.js.map